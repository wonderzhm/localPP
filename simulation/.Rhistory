# Replicate the simulation results
# Load required packages
library(parallel)
library(doParallel)
library(R2jags)
library(foreach)
library(bhmbasket)
library(basket)
library(partitions)
library(plyr)
library(cluster)
library(coda)
library(rjags)
library(BasketTrial) # install it by devtools::install_github("wonderzhm/BasketTrial")
source("../functions/functions.R")
source("../functions/functions_parallel.R")
nperclust <- 500 # number of simulated trials per cluster
detectCores()
nclust <- 10 # Total 5000 MC replicates
N <- rbind(c(10, 25),
c(10, 25),
c(10, 25),
c(10, 25),
c(10, 25)
) # interim sample size and total sample size for each indication
B <- nrow(N) # total number of baskets
p0 <- 0.15
p1 <- 0.30
p2 <- 0.45
pnull <- c(p0, p0, p0, p0, p0) # null response rate for each indication
ptarget <- c(p1, p1, p1, p1, p1) # target response rate for each indication
## BOP2 for each indication with error rate sig.level=0.1
sig.level <- 0.1 # type I error
stopbounds <- rbind(1,
1,
1,
1,
1) # obtained from BOP2 app
beta.a0 <- pnull # default beta prior
beta.b0 <- 1-pnull # default beta prior
ndigits = 3 ## number of digits for Q
## scenarios
scenarios <- rbind( c(p0, p0, p0, p0, p0),
c(p0, p0, p0, p1, p1),
c(p0, p1, p1, p1, p1),
c(p0, p1, p1, p2, p2),
c(p0, p2, p2, p2, p2),
c(p1, p1, p1, p1, p1)
)
## generate data which will be analyzed by all methods
seed <- 2024
data.object<-generate.data(N, scenarios, ntrial = nperclust*nclust, seed = seed)
####################################################################################
## Simulation results for comparing the  following eight methods:
## Independent, local PP, JSD, EXNEX, BHM, BCHM, local MEM and MEM
####################################################################################
MEM
post.infer
rm(list=ls())
# Replicate the simulation results
# Load required packages
library(parallel)
library(doParallel)
library(R2jags)
library(foreach)
library(bhmbasket)
library(basket)
library(partitions)
library(plyr)
library(cluster)
library(coda)
library(rjags)
library(BasketTrial) # install it by devtools::install_github("wonderzhm/BasketTrial")
source("../functions/functions.R")
source("../functions/functions_parallel.R")
nperclust <- 2 # number of simulated trials per cluster
detectCores()
nclust <- 10 # Total 5000 MC replicates
N <- rbind(c(10, 25),
c(10, 25),
c(10, 25),
c(10, 25),
c(10, 25)
) # interim sample size and total sample size for each indication
B <- nrow(N) # total number of baskets
p0 <- 0.15
p1 <- 0.30
p2 <- 0.45
pnull <- c(p0, p0, p0, p0, p0) # null response rate for each indication
ptarget <- c(p1, p1, p1, p1, p1) # target response rate for each indication
## BOP2 for each indication with error rate sig.level=0.1
sig.level <- 0.1 # type I error
stopbounds <- rbind(1,
1,
1,
1,
1) # obtained from BOP2 app
beta.a0 <- pnull # default beta prior
beta.b0 <- 1-pnull # default beta prior
ndigits = 3 ## number of digits for Q
## scenarios
scenarios <- rbind( c(p0, p0, p0, p0, p0),
c(p0, p0, p0, p1, p1),
c(p0, p1, p1, p1, p1),
c(p0, p1, p1, p2, p2),
c(p0, p2, p2, p2, p2),
c(p1, p1, p1, p1, p1)
)
## generate data which will be analyzed by all methods
seed <- 2024
data.object<-generate.data(N, scenarios, ntrial = nperclust*nclust, seed = seed)
shape1 <- pnull[1]
shape2 <- 1- pnull[1]
## start simulation
seed <- 2024
start_time <- Sys.time()
res.post <- post.infer.parallel(nclust = nclust, nperclust = nperclust, data.object = data.object,
pnull = pnull, stopbounds =  stopbounds, beta.a0 = pnull,
beta.b0 = 1-pnull, seed = seed, ModelFit = "MEM",
shape1 = shape1, shape2 = shape2)
(Q <- get.Q.bwer(res.post, alpha = sig.level, digits = ndigits, Qclust = rep(1, B)))
res <- get.weighted.power(res.post, Q = Q)
end_time <- Sys.time()
(time.MEM <- end_time - start_time)
## save results
results.MEM <- list(res.post, res)
Qmat <- array(NA, dim = dim(res.post$postprob))
for(i in 1:B) Qmat[,,i] <- res$Q[i]
(oc.MEM <- apply(res.post$postprob>Qmat, c(1,3), mean))
library(xtable)
####################################################################################
## Create tables for appendix
####################################################################################
load("intermediate_results/AllMethods_supp.RData")
##### Table S3 The efficacy cutoff Q_is for all considered methods.
method.names <- c("IM", "local-PP-PEB", "local-PP-GEB", "JSD",  "EXNEX")
nmethods <- length(method.names)
ii <- 2;
res.post.all <- list(results.Independent[[ii]], results.localPP_EBpairwise[[ii]],
results.localPP_EBglobal[[ii]], results.JSD[[ii]],
results.EXNEX[[ii]])
Q.by.method <- matrix(NA, nmethods, B)
rownames(Q.by.method) <- method.names
colnames(Q.by.method) <- c("Basket1", "Basket2", "Basket3", "Basket4", "Basket5")
for(i in 1:nmethods){
res <- res.post.all[[i]]
Q.by.method[i,] <- sprintf(res$Q, fmt = '%#.3f')
}
print(xtable(Q.by.method))
##### Table S4 Overall performance for different methods
results <- matrix(NA, nmethods, 5)
rownames(results) <- method.names
colnames(results) <- c("BWER_S1", "BWER-avg", "BWER-max", "TPR-avg", "CCR-avg")
ii <- 2
res.oc.all <- list(results.Independent[[ii]], results.localPP_EBpairwise[[ii]],
results.localPP_EBglobal[[ii]], results.JSD[[ii]],
results.EXNEX[[ii]])
for(i in 1:nmethods){
res <- res.oc.all[[i]]
results[i, ]<- sprintf(c(res$error.tw, mean(res$bwer, na.rm = TRUE), max(res$bwer, na.rm = TRUE),
res$power.cdr, res$power.ccr),
fmt = '%#.3f')
}
#results
print(xtable(results))
## Table S5  Results by scenarios
method.indx <- 1:5; method.names[method.indx]
method.names_sub <- c("IM", "local-PP-PEB", "local-PP-GEB", "JSD", "EXNEX")
nmethods_sub <- length(method.names_sub)
res.allmethods <- res.oc.all[method.indx]
oc.allmethods <- list(oc.Independent, oc.localPP_EBpairwise, oc.localPP_EBglobal,
oc.JSD, oc.EXNEX)
oc.by.sc <- matrix(NA, nmethods_sub, 9)
rownames(oc.by.sc) <- method.names_sub
colnames(oc.by.sc) <- c("Basket1", "Basket2", "Basket3", "Basket4", "Basket5", "FPR", "FDR", "TPR", "CCR")
res.by.sc <- list(scenario1=NULL, scenario2=NULL, scenario3=NULL,
scenario4=NULL, scenario5=NULL, scenario6=NULL)
for(k in 1:nrow(scenarios)){
for(i in 1:nmethods_sub){
res <- res.allmethods[[i]]
oc.i <- oc.allmethods[[i]]
oc.by.sc[i,1:5]<- sprintf(oc.i[k,], fmt = '%#.3f')
oc.by.sc[i,6:9]<- sprintf(c(res$ind.error.tw[k], res$ind.error.fdr[k],
res$ind.power.cdr[k], res$ind.power.ccr[k]), fmt = '%#.3f')
}
res.by.sc[[k]] <- oc.by.sc
print(paste("Scenario", k, sep=""))
print(xtable(oc.by.sc))
cat("\n")
}
#res.by.sc
## Table S2  Results by scenarios for remaining methods
method.indx <- c(2,3,5,6,8,11,12,13,14); method.names[method.indx]
method.names_sub <- c("PP-PEB", "local-PP-PEB",
"PP-GEB", "local-PP-GEB","JSD",
"BHM", "BCHM", "local-MEM", "MEM")
nmethods_sub <- length(method.names_sub)
res.allmethods <- res.oc.all[method.indx]
oc.allmethods <- list(oc.localPP_EBpairwise3, oc.localPP_EBpairwise,
oc.localPP_EBglobal3, oc.localPP_EBglobal,
oc.JSD, oc.BHMunif, oc.BCHM, oc.localMEM, oc.MEM)
library(xtable)
####################################################################################
## Create the table for local PP, JSD with different hyperparameters
## Used for tuning parameter selection in Section 3.2; not shown in the paper
####################################################################################
files <- c("intermediate_results/localPP_EBpaiwise_a_main.RData",
"intermediate_results/localPP_EBglobal_a_main.RData",
"intermediate_results/JSD_select_tau_main.RData")
list.results <- list()
for(kk in 1:3){
load(files[kk])
results <- matrix(NA, length(aseq)*length(deltaseq), 7)
colnames(results) <- c("a","delta","BWER_S1", "BWER-avg", "BWER-max", "TPR-avg", "ccr-avg")
for(i in 1:length(aseq)){
for(j in 1:length(deltaseq)){
indx <- j+(i-1)*length(deltaseq)
res <- list.metrics0[[indx]]
results[indx, ]<- sprintf(c(aseq[i], deltaseq[j], res$error.tw,
mean(res$bwer, na.rm = TRUE), max(res$bwer, na.rm = TRUE),
res$power.cdr, res$power.ccr), fmt = '%#.3f')
}
}
list.results[[kk]] <- results[order(as.numeric(results[,5])),]
}
res.PEB <- list.results[[1]]
res.GEB <- list.results[[2]]
res.JSD <- list.results[[3]]
load("C:/Users/hzhou/OneDrive - Daiichi Sankyo Global/Research/Basket Trials/Final Simulation/Code_and_Data (final)/localPP/simulation/intermediate_results/AllMethods_main.RData")
library(BasketTrial)
load("C:/Users/hzhou/Downloads/MEM.RData")
res.post <- results.MEM[[1]]
sig.level
ndigits
B
(Q <- get.Q.bwer(res.post, alpha = sig.level, digits = ndigits, Qclust = rep(1, B)))
res <- get.weighted.power(res.post, Q = Q)
## save results
results.MEM <- list(res.post, res)
Qmat <- array(NA, dim = dim(res.post$postprob))
for(i in 1:B) Qmat[,,i] <- res$Q[i]
(oc.MEM <- apply(res.post$postprob>Qmat, c(1,3), mean))
save.image("intermediate_results/AllMethods_main.RData")
# Replicate the simulation results
# Load required packages
library(parallel)
library(doParallel)
library(R2jags)
library(foreach)
library(bhmbasket)
library(basket)
library(partitions)
library(plyr)
library(cluster)
library(coda)
library(rjags)
library(BasketTrial) # install it by devtools::install_github("wonderzhm/BasketTrial")
source("../functions/functions.R")
source("../functions/functions_parallel.R")
sessionInfo()
